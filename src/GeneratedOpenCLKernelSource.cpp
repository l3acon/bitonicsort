const char * OpenCLKernelSource =
"// Sort kernels\n"
"// EB Jun 2011\n"
"\n"
"#if CONFIG_USE_VALUE\n"
"typedef uint2 data_t;\n"
"#define getKey(a) ((a).x)\n"
"#define getValue(a) ((a).y)\n"
"#define makeData(k,v) ((uint2)((k),(v)))\n"
"#else\n"
"typedef uint data_t;\n"
"#define getKey(a) (a)\n"
"#define getValue(a) (0)\n"
"#define makeData(k,v) (k)\n"
"#endif\n"
"\n"
"// One thread per record\n"
"__kernel void Copy(__global const data_t * in,__global data_t * out)\n"
"{\n"
"  int i = get_global_id(0); // current thread\n"
"  out[i] = in[i]; // copy\n"
"}\n"
"\n"
"\n"
"// N threads, WG is workgroup size. Sort WG input blocks in each workgroup.\n"
"__kernel void ParallelBitonic_Local(__global const data_t * in,__global data_t * out,__local data_t * aux)\n"
"{\n"
"  int i = get_local_id(0); // index in workgroup\n"
"  int wg = get_local_size(0); // workgroup size = block size, power of 2\n"
"\n"
"  // Move IN, OUT to block start\n"
"  int offset = get_group_id(0) * wg;\n"
"  in += offset; out += offset;\n"
"\n"
"  // Load block in AUX[WG]\n"
"  aux[i] = in[i];\n"
"  barrier(CLK_LOCAL_MEM_FENCE); // make sure AUX is entirely up to date\n"
"\n"
"  // Loop on sorted sequence length\n"
"  for (int length=1;length<wg;length<<=1)\n"
"  {\n"
"    bool direction = ((i & (length<<1)) != 0); // direction of sort: 0=asc, 1=desc\n"
"    // Loop on comparison distance (between keys)\n"
"    for (int inc=length;inc>0;inc>>=1)\n"
"    {\n"
"      int j = i ^ inc; // sibling to compare\n"
"      data_t iData = aux[i];\n"
"      uint iKey = getKey(iData);\n"
"      data_t jData = aux[j];\n"
"      uint jKey = getKey(jData);\n"
"      bool smaller = (jKey < iKey) || ( jKey == iKey && j < i );\n"
"      bool swap = smaller ^ (j < i) ^ direction;\n"
"      barrier(CLK_LOCAL_MEM_FENCE);\n"
"      aux[i] = (swap)?jData:iData;\n"
"      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"  }\n"
"\n"
"  // Write output\n"
"  out[i] = aux[i];\n"
"}\n"
"__kernel void ParallelBitonic_Local_Optim(__global const data_t * in,__global data_t * out,__local data_t * aux)\n"
"{\n"
"  int i = get_local_id(0); // index in workgroup\n"
"  int wg = get_local_size(0); // workgroup size = block size, power of 2\n"
"\n"
"  // Move IN, OUT to block start\n"
"  int offset = get_group_id(0) * wg;\n"
"  in += offset; out += offset;\n"
"\n"
"  // Load block in AUX[WG]\n"
"  data_t iData = in[i];\n"
"  aux[i] = iData;\n"
"  barrier(CLK_LOCAL_MEM_FENCE); // make sure AUX is entirely up to date\n"
"\n"
"  // Loop on sorted sequence length\n"
"  for (int length=1;length<wg;length<<=1)\n"
"  {\n"
"    bool direction = ((i & (length<<1)) != 0); // direction of sort: 0=asc, 1=desc\n"
"    // Loop on comparison distance (between keys)\n"
"    for (int inc=length;inc>0;inc>>=1)\n"
"    {\n"
"      int j = i ^ inc; // sibling to compare\n"
"      data_t jData = aux[j];\n"
"      uint iKey = getKey(iData);\n"
"      uint jKey = getKey(jData);\n"
"      bool smaller = (jKey < iKey) || ( jKey == iKey && j < i );\n"
"      bool swap = smaller ^ (j < i) ^ direction;\n"
"      iData = (swap)?jData:iData; // update iData\n"
"      barrier(CLK_LOCAL_MEM_FENCE);\n"
"      aux[i] = iData;\n"
"      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"  }\n"
"\n"
"  // Write output\n"
"  out[i] = iData;\n"
"}\n"
"\n"
"\n"
"#define ORDERV(x,a,b) { bool swap = reverse ^ (getKey(x[a])<getKey(x[b])); \\\n"
"      data_t auxa = x[a]; data_t auxb = x[b]; \\\n"
"      x[a] = (swap)?auxb:auxa; x[b] = (swap)?auxa:auxb; }\n"
"#define B2V(x,a) { ORDERV(x,a,a+1) }\n"
"#define B4V(x,a) { for (int i4=0;i4<2;i4++) { ORDERV(x,a+i4,a+i4+2) } B2V(x,a) B2V(x,a+2) }\n"
"#define B8V(x,a) { for (int i8=0;i8<4;i8++) { ORDERV(x,a+i8,a+i8+4) } B4V(x,a) B4V(x,a+4) }\n"
"#define B16V(x,a) { for (int i16=0;i16<8;i16++) { ORDERV(x,a+i16,a+i16+8) } B8V(x,a) B8V(x,a+8) }\n"
;
